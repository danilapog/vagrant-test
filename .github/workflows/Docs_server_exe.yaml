name: Docs Server Test EXE (amd64/arm64)

run-name: >-
    CI Docs Windows [Build #${{ inputs.build }} 
                          Arch: ${{ inputs.arch }} 
                          Version: ${{ inputs.version }}
                    ]
                    [
                    ${{ inputs.community && 'CE' || '-' }}
                    ${{ inputs.developer && 'DE' || '-' }}
                    ${{ inputs.enterprise && 'EE' || '-' }}
                    ]

on:
  #push:
  workflow_dispatch:
    inputs:
      build:
        description: 'Please specify windows package build'
        type: string
        required: true
      version:
        description: 'Please specify windows package version'
        type: string
        required: true
      arch:
        type: string
        description: 'Type arch amd64 or arm64'
        required: true
      community:
        type: boolean
        description: 'Test Exe Community Edition'
        default: true
      enterprise:
        type: boolean
        description: 'Test Exe Enterprise Edition'
        default: true
      developer:
        type: boolean
        description: 'Test Exe Developer Edition'
        default: true

jobs:
  prepare:
    runs-on: ubuntu-latest
    steps:
      - id: matrix
        env:
          BRANCH_NAME: ${{ github.ref_name }}
          AMD64: ${{ github.event.inputs.amd64 }}
          ARM64: ${{ github.event.inputs.arm64 }}
          COMMUNITY: ${{ github.event.inputs.community }}
          ENTERPRISE: ${{ github.event.inputs.enterprise }}
          DEVELOPER: ${{ github.event.inputs.developer }}
        run: |
          set -ex

          [ "${COMMUNITY}" = true ] && EDITIONS+=("community")
          [ "${ENTERPRISE}" = true ] && EDITIONS+=("enterprise")
          [ "${DEVELOPER}" = true ] && EDITIONS+=("developer")
          if [ -z ${EDITIONS} ]; then
            echo "None of the editions are selected."
            exit 1
          fi
          echo "editions=$(jq -n -c --arg s "${EDITIONS[*]}" '($s|split(" "))')" >> $GITHUB_OUTPUT
    outputs:
      editions: ${{ steps.matrix.outputs.editions }}
      
  test:
    needs: prepare
    name: "Test Win ONLYOFFICE-Docs-${{ matrix.edition }}-${{ github.event.inputs.version }}"
    runs-on: 'windows-latest'
    env:
      VERSION: ${{ github.event.inputs.version }}
      BUILD: ${{ github.event.inputs.build }}
      EDITION: ${{ matrix.edition }}
    strategy:
      fail-fast: false
      matrix:
        edition: ${{ fromJSON(needs.prepare.outputs.editions) }}
    steps:
      - uses: ikalnytskyi/action-setup-postgres@v8
        with:
          username: postgres
          password: postgres
          database: postgres
          port: 5432
          postgres-version: "14"
          ssl: true
        id: postgres
    
      - name: Download
        run: |
           switch ($EDITION) {
                 "community"  { $env:PRODUCT_EDITION = "" }
                 "enterprise" { $env:PRODUCT_EDITION = "-ee" }
                 "developer"  { $env:PRODUCT_EDITION = "-de" }
           }
           curl -L "${{ secrets.PACKAGE_URL }}/server/win/inno/ONLYOFFICE-DocumentServer-Prerequisites-$VERSION.$BUILD-x64.exe" -o ONLYOFFICE-DocumentServer-Prerequisites-$VERSION.$BUILD-x64.exe 
           curl -L "${{ secrets.PACKAGE_URL }}/server/win/inno/ONLYOFFICE-DocumentServer$PRODUCT_EDITION-$VERSION.$BUILD-x64.exe" -o ONLYOFFICE-DocumentServer-$VERSION.$BUILD-x64.exe
           
      - name: Install
        shell: cmd
        run: |
           ONLYOFFICE-DocumentServer-Prerequisites-$VERSION.$BUILD-x64.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /LOG="C:\install-log-rpeq.txt"
           ONLYOFFICE-DocumentServer-$VERSION.$BUILD-x64.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /DS_PORT=8200 /LOG="C:\install-log.txt"
    
      - name: Verify
        run: |
         ls "C:\Program Files\ONLYOFFICE\DocumentServer"
         if (!(Test-Path "C:\Program Files\ONLYOFFICE\DocumentServer")) {
              Write-Error "App not installed!"
         }

         Write-Host "== Running services =="
         Get-Service -ErrorAction SilentlyContinue | Where-Object { $_.Status -eq "Running" }
    
         Write-Host "== ONLYOFFICE services =="
         Get-Service -ErrorAction SilentlyContinue | Where-Object { $_.Name -like "*onlyoffice*" -or $_.DisplayName -like "*onlyoffice*" }
    
         Write-Host "== Processes =="
         Get-Process
    
         Write-Host "== Open ports =="
         netstat -ano

      - name: get service logs
        if: always()
        run: |
          $logRoot = "C:\Program Files\ONLYOFFICE\DocumentServer\Log"
          $nginxLogs = "C:\Program Files\ONLYOFFICE\DocumentServer\nginx\logs"
            
          Write-Host "=== NGINX LOGS ==="
          if (Test-Path $nginxLogs) {
              Get-ChildItem -Recurse $nginxLogs | ForEach-Object {
                  if (-not $_.PSIsContainer) {
                      Write-Host "`n--- $($_.FullName) ---"
                      try { Get-Content $_.FullName -ErrorAction Stop }
                      catch { Write-Host "ERROR: $($_.Exception.Message)" }
                  }
              }
          }
            
          Write-Host "`n=== DOCUMENTSERVER LOGS ==="
          if (Test-Path $logRoot) {
              Get-ChildItem -Recurse $logRoot | ForEach-Object {
                  if (-not $_.PSIsContainer) {
                      Write-Host "`n--- $($_.FullName) ---"
                      try { Get-Content $_.FullName -ErrorAction Stop }
                      catch { Write-Host "ERROR: $($_.Exception.Message)" }
                  }
              }
          } else {
              Write-Host "Log root directory not found: $logRoot"
          }
            
      - name: Wait for healthcheck (with detailed logging)
        shell: pwsh
        run: |
            $timeout = 300    
            $interval = 5      
            $elapsed = 0
        
            Write-Host "Waiting for healthcheck at http://127.0.0.1:8200/healthcheck ..."
        
            while ($elapsed -lt $timeout) {
                try {
                    $response = Invoke-WebRequest -Uri "http://127.0.0.1:8200/healthcheck" -UseBasicParsing -TimeoutSec 2
                    $body = $response.Content.Trim()
        
                    Write-Host "[$elapsed sec] Got response:"
                    Write-Host "  StatusCode: $($response.StatusCode)"
                    Write-Host "  Body: '$body'"
        
                    if ($body -eq "true") {
                        Write-Host "Healthcheck OK!"
                        exit 0
                    }
                }
                catch {
                    Write-Host "[$elapsed sec] ERROR calling endpoint:"
                    Write-Host "  $($_.Exception.Message)"
                }
        
                Start-Sleep -Seconds $interval
                $elapsed += $interval
            }
        
            Write-Error "Service did NOT return 'true' within 5 minutes!"
            exit 1
